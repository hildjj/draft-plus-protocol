<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY I-D.ietf-taps-transports SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-taps-transports.xml">
]>


<rfc ipr="trust200902" docName="draft-hildebrand-plus-protocol" category="std">

  <front>
    <title abbrev="plus-protocol">PLUS Protocol</title>

    <author initials="J." surname="Hildebrand" fullname="Joe Hildebrand">
      <organization>Cisco Systems</organization>
      <address>
        <email>jhildebr@cisco.com</email>
      </address>
    </author>
    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich</organization>
      <address>
        <email>ietf@trammell.ch</email>
      </address>
    </author>

    <date year="2016" month="August" day="04"/>

    
    
    

    <abstract>


<t>Minimal in-band firewall and load balancer signaling for UDP.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document defines a common minimal path layer protocol for UDP-
encapsulated transport protocols with  in order to provide minimal, transport-
independent state exposure to support firewall and load balancer operation
[EDITOR’S NOTE cite appropriate section of draft-kuehlewind-plus-ps once it
exists].</t>

<section anchor="requirements" title="Requirements">

<t><list style="symbols">
  <t>Hint to Initiator’s network path that PLUS is likely in use</t>
  <t>Hint to Initiator’s network path that Initiator wants to initiate a new
connection</t>
  <t>Further indication to path that PLUS protocol is in use when Responder’s
messages are seen by the path, better than 5-tuple.</t>
  <t>Matching Responder’s packets to Initiator’s intent to communicate, better
than 5-tuple</t>
</list></t>

</section>
</section>
<section anchor="terminology" title="Terminology">

<t><list style="symbols">
  <t>Initiator: The active opener of a transport-layer association. In a client-
server protocol, this is generally the client.</t>
  <t>Responder: The listener (passive opener) of a transport-layer association.
In a client-server protocol, this is generally the server.</t>
  <t>Upper-layer transport: The transport protocol which uses PLUS for
common signaling.</t>
</list></t>

</section>
<section anchor="protocol-specification" title="Protocol Specification">

<t>The PLUS protocol fits between the UDP header and the (encrypted) upper layer
transport header and payload, adding eight bytes to each packet sent by the
initiator, and four bytes to each packet sent by the responder. The initiator’s
PLUS header allows elements on the network path that can see both inbound and
outbound traffic for an association (including typical firewalls and load
balancers) to group packets together into flows with better accuracy than
provided by the 5-tuple of (Source Address, Source Port, Destination Address,
Destination Port, Protocol).</t>

<section anchor="initiator_bits" title="Bit pattern: Initiator">

<figure><artwork><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      UDP Source Port          |   UDP Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         UDP Length            |      UDP Checksum             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             Magic                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|             Association Token                 |R|X|   tflags  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Upper Layer Transport Header/Payload             |
|                             . . .                             |

]]></artwork></figure>

<t>The following bits are defined:</t>

<t><list style="symbols">
  <t>Magic: 32 bits. Magic numbers should be chosen such that they do not appear as
the first 32 bits of any widely deployed UDP-based protocol, to allow
initiator packets to be probabilistically separated from reflected UDP
traffic. For the version of the PLUS protocol described in this document, the
value of the Magic field is 0xd80000d8.</t>
  <t>Association Token: 24 bits. A cryptographically random token chosen by the
initiator for this association.</t>
  <t>R bit (Reset): The initiator sets this bit to indicate the association is
closing.</t>
  <t>X bit (Reserved): Reserved for future use in this protocol. Must be zero.</t>
  <t>tflags: 6 bits: available for use in the next layer</t>
</list></t>

</section>
<section anchor="responder_bits" title="Bit pattern: Responder">

<figure><artwork><![CDATA[
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Source Port           |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         UDP Length            |          Checksum             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        HMAC                   |R|X|   tflags  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork></figure>

<t>The following bits are defined:</t>

<t><list style="symbols">
  <t>hmac, 24 bits: HMAC_SHA256(magic, ConnectionID), truncated</t>
  <t>R, 1 bit: Reset</t>
  <t>X, 1bits: reserved for future use in this protocol</t>
  <t>tflags: 6 bits: available for use in the next layer</t>
</list></t>

</section>
<section anchor="indication-of-implementation" title="Indication of implementation">

<t>The receiver performs HMAC_256(0xd80000d8, Association Token), and uses the
first 3 bytes as the first 3 bytes of the reply.  This is used as a further
hint that the magic number use was intentional.  Call this function
Indicator(Association Token).</t>

<t>Usefully, none of these truncated HMACs return the magic number.</t>

</section>
<section anchor="reset-bit" title="Reset bit">

<t>Set the Reset bit to tell the path that you’re shutting down.  Work will need
to be done on this section to define what actions the path will take; one
possible approach is to shorten the association timer to a smaller, constant
value.</t>

<t>Upper-layer transports should consider providing security around this bit
before trusting that it comes from the other endpoint.</t>

</section>
</section>
<section anchor="processing" title="Processing">

<t>Basic idea: Initiator sends bits defined in <xref target="initiator_bits"/>, Responder
sends bits defined in <xref target="responder_bits"/>.  Initiator always has to send first
over every new path.</t>

<section anchor="processing-by-applications" title="Processing by applications">

<t><list style="symbols">
  <t>If the RSV bit is set, ignore the packet</t>
  <t>Initiator: If the hmac doesn’t match what you expect, it’s either an attack
or leftover traffic from a previous connection.  Maybe send an unsigned RST?
(maybe this is a policy or transport-specific decision)</t>
  <t>Responder: If the magic number isn’t there, it’s likely an attack.  Probably
best to ignore it.</t>
</list></t>

</section>
<section anchor="processing-by-path-elements" title="Processing by path elements">

<t><list style="symbols">
  <t>Assume that all bits are protected by next layer, so you can’t change them.
Even if you could change them, you may as well just drop the packet, since
delivery won’t work.</t>
  <t>Don’t think that having RSV set means this is an attack.  It’s just
something we haven’t specified as of the time you wrote your code.</t>
</list></t>

</section>
<section anchor="from-inside-to-outside" title="From inside to outside:">

<t><list style="symbols">
  <t>Match magic number
  <list style="symbols">
      <t>If not, treat as non-PLUS UDP</t>
    </list></t>
  <t>Forward 6tuple = 5tuple + Association Token</t>
  <t>Reverse 6tuple = Reverse 5tuple + Indicator(Association Token)</t>
  <t>Look up Forward
  <list style="symbols">
      <t>If not, create state keyed by Forward and Reverse</t>
    </list></t>
  <t>Reset timer
  <list style="symbols">
      <t>When timer fires, either drop state or send RST hint both ways without
e2e crypto</t>
    </list></t>
  <t>Allow</t>
</list></t>

</section>
<section anchor="from-outside-to-inside" title="From outside to inside:">

<t><list style="symbols">
  <t>Look up Reverse, allow if match
  <list style="symbols">
      <t>If not, treat as non-PLUS UDP</t>
    </list></t>
</list></t>

<t>(TODO: determine if reverse timer is useful)</t>

</section>
</section>
<section anchor="guidelines-for-next-layer" title="Guidelines for next layer">

<t>New transport’ protocols like QUIC.</t>

<t><list style="symbols">
  <t>Define tflags as you see fit</t>
  <t>Consider if these bits need protection.  At least tflags do.</t>
  <t>Consider multipath consequences, send before you receive on each path, and
consider using a different Association Token on different paths to make
tracking harder.  If so, figure out how load balancers are going to deal with
the problem.</t>
</list></t>

</section>
<section anchor="security" title="Security Considerations">

<t>Next layer transport protocols SHOULD discuss whether any of these bits need
to be protected.</t>

<t>Discuss the actual number of bits that window tracking gives you for TCP.
Contrast this with how useful this would be for tracking people.</t>

<t>Association Tokens MUST NOT be under the control of untrusted code, like
JavaScript.  It’s likely there’s a reason for making them not available to
untrusted code as well.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>Do we need a registry of magic numbers?</t>

</section>


  </middle>

  <back>


    <references title='Informative References'>

&I-D.ietf-taps-transports;


    </references>



  </back>
</rfc>

